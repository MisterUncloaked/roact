To facilitate writing robust unit tests when using Roact, utilities are provided for shallow rendering and snapshotting components. Shallow rendering involves rendering 1 or more levels deep to assert facts about the rendered elements, allowing components to be tested as units. Snaphotting involves converting these shallow renders to serializable Lua modules for debugging purposes or to verify that components have not changed unexpectedly.

## Shallow Wrapper

When writing tests for Roact components, the `VirtualTree` returned by `Roact.mount` can provide a `ShallowWrapper` object with an interface designed to help make assertions about the expected behavior of a component.

```lua
-- let's assume there is a ComponentToTest that we want to test

local tree = Roact.mount(ComponentToTest)

local shallowWrapper = tree:getShallowWrapper()
```

### TODO: Testing Shallows Using Find
We should have a section on how and when to use find/findUnique

## Snapshots

A snapshot is a serializable representation of a shallow rendered Roact tree that can be serialized as a complete Lua `ModuleScript`. The snapshot can either be compared with a past snapshot written to `ReplicatedStorage` or returned as a string for debugging purposes.

### Snapshot Testing

The goal of a snapshot test is to verify that the shallow render matches the version saved previously. If a snapshot does not match, then the component may have changed unexpectedly. Snapshot testing can be done through the `matchSnapshot` method on the `ShallowWrapper`. The single argument of `matchSnapshot` is the name of the `ModuleScript` in `ReplicatedStorage` to look for.

```lua
shallowWrapper:matchSnapshot("ComponentToTest")
```

Here is a breakdown of how matching is performed:

1. Check if there is an existing snapshot with the given name
2. If no snapshot exists, generate a new one from the `ShallowWrapper` and exit, else continue
3. Load the existing snapshot by calling require on the `ModuleScript`
4. Compare the existing snapshot with the one generated by the `ShallowWrapper`
5. If the snapshots match, exit, else save the new `ModuleScript` (useful for comparison) and throw an error

!!! Note
	Currently, the `ModuleScript` for new snapshots will be stored in a `StringValue`. The permission level where the test are ran does not make it possible to create a `ModuleScript` and assign its `Source` property. Tools like Roact's SnapshotsPlugin can copy the `StringValue` from Run mode to a `ModuleScript` in Edit mode.

!!! Note
	The scripts generated by `matchSnapshot` are not guaranteed to pass [luacheck](https://github.com/mpeterv/luacheck/) due to the potential for unused variables, so be careful not to run `luacheck` on them.
---

#### Workflow Example

For a concrete example, suppose the following component `ComponentToTest`.

```lua
local function ComponentToTest(props)
	return Roact.createElement("TextLabel", {
		Text = "foo",
	})
end
```

A snapshot test could be written this way:

```lua
it("should match the snapshot", function()
	local element = Roact.createElement(ComponentToTest)
	local tree = Roact.mount(element)
	local shallowWrapper = tree:getShallowWrapper()

	shallowWrapper:matchSnapshot("ComponentToTest")
end)
```

After the first run, the test will have created a new script under `RoactSnapshots` in `ReplicatedStorage` called `ComponentToTest` that contains the following Lua code:

```lua
return function(dependencies)
  local Roact = dependencies.Roact
  local ElementKind = dependencies.ElementKind
  local Markers = dependencies.Markers

  return {
    type = {
      kind = ElementKind.Host,
      className = "TextLabel",
    },
    hostKey = "RoactTree",
    props = {
      Text = "foo",
    },
    children = {},
  }
end
```

Since these tests require the previous snapshots to compare with the current generated one, snapshots should be saved (if using Studio) or committed to version control (if using file system development).

Suppose now `ComponentToTest` is updated as follows:

```lua
local function ComponentToTest(props)
	return Roact.createElement("TextLabel", {
		Text = "bar",
	})
end
```

When the test is run again, it will fail, noting that the snapshots did not match. There will be a new script under `RoactSnapshots` called `ComponentToTest.NEW` that shows the new version of the snapshot.

```lua
return function(dependencies)
  local Roact = dependencies.Roact
  local ElementKind = dependencies.ElementKind
  local Markers = dependencies.Markers

  return {
    type = {
      kind = ElementKind.Host,
      className = "TextLabel",
    },
    hostKey = "RoactTree",
    props = {
      Text = "bar",
    },
    children = {},
  }
end
```

Only the `Text` prop value changed, from *foo* to *bar*. Since these changes are expected from the modification made to the component, we can delete the old snapshot and remove the `.NEW` from the newest one. If the tests are run again, they will once again pass.

Updated snapshots should be saved / committed along with the component changes to make it clear why the snapshot is being changed.

Most snapshots will be more complex than this example and act as a powerful line of defense against unexpected changes to components.

---

#### Where They Are Good

##### Regression

Snapshot tests really shine when comes the time to test for regression.

##### Carefully Reviewed

Changes made to a snapshot file needs to be reviewed carefully as if it was hand written code. A reviewer needs to be able to catch any unexpected changes to a component. Any source control software should provide some way to see a diff of the changes that are going to be submitted. If a snapshot diff shows a difference in the color property for a change that is supposed to update  sizing, the reviewer should verify that the change is intended.

---

#### Where They Are Bad

##### Large Snapshots

If a snapshot is created from a top level component with a ShallowWrapper that renders many levels deep, it can produce a large snapshot file with potentially hundreds of lines. The larger the snapshot, the more likely it is to fail due to a reason unrelated to the component being tested.

Large snapshots also become an inconvenience and may not be reviewed correctly due to their size or frequency of needing an update, or both.

To avoid this situation, it is important that each snapshot is kept as simple and as small as possible. That is why the `ShallowWrapper` is deeply linked with snapshot generation and defaults to rendering only 1 level deep. Render more deeply only as needed to exercise the component being tested.

---

#### Managing Snapshots

When the tests are executed in Run mode (after Run is pressed), snapshots are serialized and saved as `StringValue` objects inside of `ReplicatedStorage.RoactSnapshots`. Pressing Stop to go back to Edit mode will delete any newly created snapshots values. Preserving the serialized snapshots and saving them as module scripts is necessary to ensure that there are snapshots to match with during future test runs. The method of preserving them varies based on the development environment being used.

##### Roblox Studio
 If using Roblox Studio for development, install the `RoactSnapshots` plugin, which will preserve the `StringValue` objects and save them as `ModuleScript` objects upon returning to Edit mode.

---

##### File System

If using a tool like `rojo` to sync files to Roblox Studio, a tool like `run-in-roblox` can help write the module scripts back to the file system.

[`run-in-roblox`](https://github.com/LPGhatguy/run-in-roblox/) is a [`Rust`](https://www.rust-lang.org/) command line tool that runs Roblox Studio and sends content from the output to the shell window. Using this tool, a script can be written to open a place file and run it with a specific test runner that can print out the new snapshots in a special format. Then, the output can be parsed to find the new snapshots and write them to files.

Here are examples of this kind of script written in Lua ([link](../scripts/sync-snapshots-with-lua.md)) and in python ([link](../scripts/sync-snapshots-with-python.md)) (compatible with version 2 and 3). These example scripts assume that the `rojo` and `run-in-roblox` commands are available. They build a place from a `rojo` configuration file, run a specific script inside studio, print the serialized snapshots, parse them from the output, and write them to the file system.
